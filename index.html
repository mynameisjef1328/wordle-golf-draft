<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Wordle Golf Scorecard</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; background: #f9f9f9; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
    th { background-color: #999; color: white; }
    .under-par { background-color: lightgreen; }
    .over-par  { background-color: lightcoral; }
    .even-par  { background-color: white; }
    input[type="number"] { width: 50px; text-align: center; display: inline-block; vertical-align: middle; }
    input[type="text"] { width: 100px; }
    
    .player-label td {
  font-weight: bold;
  background: #eee;
  text-align: left;
}

    /* Mini scoreboard box */
#miniBoard {
  position: fixed;
  bottom: max(12px, env(safe-area-inset-bottom));
  left: max(12px, env(safe-area-inset-left));
  min-width: 180px;
  max-width: 260px;
  padding: 10px 12px;
  background: #eee;
  border: 1px solid #ccc;
  border-radius: 8px;
  font: 14px/1.4 system-ui, -apple-system, Arial, sans-serif;
  box-shadow: 0 2px 8px rgba(0,0,0,.08);
  color: #111;
  z-index: 4; /* above table sticky headers */
}
#miniBoard h4 { margin: 0 0 6px 0; font-size: 14px; font-weight: 700; }
#miniBoard .row { display: flex; justify-content: space-between; gap: 8px; padding: 2px 0; }
#miniBoard .name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
#miniBoard .score { font-variant-numeric: tabular-nums; }

    /* Word of the Day box */
/* Word of the Day card */
#wordBox{
  position: fixed;
  bottom: max(12px, env(safe-area-inset-bottom));
  center: 220px;
  max-width: 900px;
  background: #0B6623;      /* Masters green */
  border: 3px solid #084d1a; /* darker green border */
  border-radius: 8px;
  padding: 14px 16px;
  box-shadow: 0 2px 10px rgba(0,0,0,.2);
  color: #fff;              /* white text for contrast */
  font-size: 23px;
  font-weight: bold;        /* bold text */
  line-height: 1.6;
  z-index: 4;
}
    
@media (max-width: 700px){
  #wordBox{ width: calc(100% - 24px); left: 50%; transform: translateX(-50%); }
}

@media (max-width: 600px){
  #miniBoard {
    bottom: max(8px, env(safe-area-inset-bottom));
    left: max(8px, env(safe-area-inset-left));
    min-width: 150px;
    padding: 8px 10px;
  }
}

/* keep sticky cells opaque over scrolled content */
th:first-child, td:first-child { 
  position: sticky;
  left: 0;
  background: #eee;            /* already set */
  z-index: 2;
  background-clip: padding-box; /* avoids odd borders on iOS */
}

/* keep header row on top while scrolling */
thead th {
  position: sticky;
  top: 0;
  z-index: 3;
  background: #999;            /* match your header color while sticky */
}

/* optional: subtle divider where the sticky column meets the rest */
th:first-child, td:first-child { box-shadow: 2px 0 0 rgba(0,0,0,.06); }
    
  </style>
</head>
<body>
  <h2>Wordle Golf Scorecard</h2>

  <label for="courseSelect">Choose a course:</label>
  <select id="courseSelect"></select>
  <button id="clearBtn" style="margin-left:12px;">Clear Scores</button>
  <button id="clearNamesBtn" type="button" style="margin-left:8px;">Clear Names</button>

  <table id="scorecard">
    <thead>
      <tr>
        <th></th>
        <th colspan="18">Hole</th>
        <th>Total</th>
        <th>+/-</th>
      </tr>
      <tr>
        <th></th>
        <script>
          for (let i = 1; i <= 18; i++) document.write(`<th>${i}</th>`);
        </script>
        <th>Par</th>
        <th></th>
      </tr>
      <tr id="parRow"><th>Par</th></tr>
    </thead>
    <tbody></tbody>
  </table>

<!-- mini scoreboard goes right after the table closes -->
<div id="miniBoard" aria-live="polite"></div>

<!-- Word of the Day box -->
<div id="wordBox" aria-live="polite"></div>
  
  <!-- MOVE THE SCRIPT OUTSIDE TBODY -->
  <script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
  import { getFirestore, doc, getDoc, setDoc, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyC9-Z6E59grKoq_pD8acGTre2Jx-1NQ_Qc",
    authDomain: "wordle-golf-6c636.firebaseapp.com",
    projectId: "wordle-golf-6c636",
    storageBucket: "wordle-golf-6c636.appspot.com",
    messagingSenderId: "672104265687",
    appId: "1:672104265687:web:2c16b0539fcd52ca4d7d92"
  };

  let app, db;
(async () => {
  try {
    app = initializeApp(firebaseConfig);
    db  = getFirestore(app);
    console.log("Firebase OK:", firebaseConfig.projectId);

    // optional quick ping
    await setDoc(doc(db, "diagnostics", "ping"),
      { ok: true, ts: Date.now() }, { merge: true });
    console.log("Ping wrote");
  } catch (e) {
    console.error("Firebase init/ping error:", e);
  }
})();

    async function testWriteCourse(course = "Bully Pulpit") {
  try {
    await setDoc(doc(db, "wordleScorecards", course), {
      course,
      players: [
        { name: "Tester 1", scores: ["3","4","","","","","","","","","","","","","","","",""] },
        { name: "Tester 2", scores: [] },
        { name: "Player 3", scores: [] },
        { name: "Player 4", scores: [] }
      ],
      updatedAt: serverTimestamp()
    }, { merge: true });
    console.log("testWriteCourse OK");
  } catch (e) {
    console.error("testWriteCourse error:", e);
  }
}

testWriteCourse(); // runs once on load

  // ...keep the rest of your scorecard code here (courses, updateParRow, buildPlayerRow, saveScoresToFirestore, etc.)

    // ---------- Data ----------
    const courses = {
      'Sweetwater Creek': [4,4,3,4,5,4,4,3,5,4,3,4,5,4,4,3,4,5],
      'St. Andrews':  [4,5,4,3,4,4,5,3,4,4,3,5,4,4,3,4,5,4],
      'Augusta':      [5,4,3,4,5,3,4,4,4,3,5,4,4,3,4,5,4,3],
      'Bully Pulpit':  [4,3,5,4,4,3,4,5,4,4,3,4,4,5,3,4,5,4],
      'Torrey Pines': [4,4,5,3,4,5,4,3,4,4,4,5,3,4,4,5,3,4],
      'TPC Sawgrass': [4,4,3,5,4,3,4,5,4,3,4,5,4,4,3,5,4,3],
      'Bethpage Black': [4,5,3,4,4,5,4,4,3,4,5,3,4,4,5,3,4,4],
      'Whistling Straits': [4,3,5,4,4,5,3,4,4,5,4,3,4,4,5,4,3,4],
      'Pebble Beach': [4,4,5,3,4,3,4,5,4,4,4,5,3,4,4,5,3,4],
      'Congrssional': [3,4,5,4,3,5,4,4,4,5,4,3,4,5,4,4,3,4]
    };

    const parRow        = document.getElementById('parRow');
    const courseSelect  = document.getElementById('courseSelect');
    const tbody         = document.querySelector('#scorecard tbody');

    // Populate course dropdown
    Object.keys(courses).forEach(course => {
      const option = document.createElement('option');
      option.value = course;
      option.textContent = course;
      courseSelect.appendChild(option);
    });

    let currentPar = [];
    let unsubscribe = null;
    let applyingRemote = false;

    function updateParRow(parValues) {
      parRow.innerHTML = '';
      parRow.innerHTML += '<th></th>';
      parValues.forEach(par => {
        const th = document.createElement('th');
        th.textContent = par;
        parRow.appendChild(th);
      });
      const parTotal = parValues.reduce((sum, p) => sum + p, 0);
      parRow.innerHTML += `<th>${parTotal}</th>`;
      parRow.innerHTML += '<th></th>';
    }

    function buildPlayerRow(name = '', rowIndex = 0, savedScores = []) {
      const row = document.createElement('tr');

      const nameCell = document.createElement('td');
      const nameInput = document.createElement('input');
      nameInput.type = 'text';
      nameInput.value = name;
      nameInput.addEventListener('input', () => saveScoresToFirestore());
      nameCell.appendChild(nameInput);
      row.appendChild(nameCell);

      for (let i = 0; i < 18; i++) {
        const cell = document.createElement('td');
        const input = document.createElement('input');
        input.type = 'number';
        input.min = 1;
        input.value = savedScores[i] || '';
        input.addEventListener('input', () => {
          calculate(row);
          saveScoresToFirestore();
        });
        cell.appendChild(input);
        row.appendChild(cell);
      }

      const totalCell = document.createElement('td');
      totalCell.className = 'total';
      totalCell.textContent = '0';
      row.appendChild(totalCell);

      const diffCell = document.createElement('td');
      diffCell.className = 'diff';
      diffCell.textContent = '0';
      row.appendChild(diffCell);

      setTimeout(() => calculate(row), 0);
      return row;
    }

    function calculate(row) {
  const inputs = row.querySelectorAll('input[type="number"]');
  let total = 0;
  let parTotal = 0;

  inputs.forEach((input, index) => {
    const val = parseInt(input.value);
    const par = currentPar[index];
    const cell = input.parentElement;
    cell.className = '';
    if (!isNaN(val)) {
      total += val;
      parTotal += par;
      if (val < par) cell.className = 'under-par';
      else if (val > par) cell.className = 'over-par';
      else cell.className = 'even-par';
    }
  });

  row.querySelector('.total').textContent = total || '0';
  const diff = total - parTotal;
  row.querySelector('.diff').textContent = total
    ? (diff > 0 ? `+${diff}` : `${diff}`)
    : '0';

  // keep the mini board in sync
  updateMiniBoard();
}

function updateMiniBoard() {
  const box = document.getElementById('miniBoard');
  if (!box) return;

  const rows = Array.from(tbody.querySelectorAll('tr'));
  const items = rows
    .map(r => {
      const name = r.querySelector('input[type="text"]')?.value?.trim() || '';
      const total = parseInt(r.querySelector('.total')?.textContent || '0', 10) || 0;
      const diffTxt = (r.querySelector('.diff')?.textContent || '0').toString();
      return { name, total, diffTxt };
    })
    .filter(p => p.name);

  if (!items.length) {
    box.innerHTML = `<h4>Live Scores</h4>
      <div class="row"><span class="name">Enter scores to begin</span></div>`;
    return;
  }

  // sort by best total
  items.sort((a, b) => (a.total || 9999) - (b.total || 9999));

  box.innerHTML =
    `<h4>Live Scores</h4>` +
    items
      .map(
        p => `<div class="row">
                <span class="name">${p.name}</span>
                <span class="score">${p.total} (${p.diffTxt})</span>
              </div>`
      )
      .join('');
}

    // ---------- Firestore helpers ----------
    const buildDefaultPlayers = () =>
      Array.from({ length: 4 }, (_, i) => ({ name: `Player ${i + 1}`, scores: [] }));

    function readTableData() {
      const data = { course: courseSelect.value, players: [] };
      tbody.querySelectorAll('tr').forEach(row => {
        const name = row.querySelector('input[type="text"]')?.value || '';
        const scores = Array.from(row.querySelectorAll('input[type="number"]')).map(i => i.value);
        data.players.push({ name, scores });
      });
      return data;
    }

    async function saveScoresToFirestore() {
      if (applyingRemote || !db) return;
      const data = readTableData();
      const ref = doc(db, 'wordleScorecards', data.course);
      await setDoc(ref, { course: data.course, players: data.players, updatedAt: serverTimestamp() }, { merge: true });
    }

    function sameData(a, b) {
      try { return JSON.stringify(a) === JSON.stringify(b); } catch { return false; }
    }

    function renderFromData(docData) {
  tbody.innerHTML = '';

  // Add the Player label row at the very top
  const labelRow = document.createElement('tr');
  labelRow.classList.add('player-label');
  const labelCell = document.createElement('td');
  labelCell.textContent = 'Player';
  labelRow.appendChild(labelCell);

  // Fill the rest of that row with empty cells to keep alignment
  for (let i = 0; i < 20; i++) {  // 18 holes + Total + Diff
    labelRow.appendChild(document.createElement('td'));
  }
  tbody.appendChild(labelRow);

  // Then build actual player rows
  const players = docData?.players?.length ? docData.players : buildDefaultPlayers();
  players.forEach((p, i) => tbody.appendChild(buildPlayerRow(p.name, i, p.scores || [])));

  updateMiniBoard(); // keep floating box in sync
}

    async function ensureDocExists(courseName) {
      if (!db) return;
      const ref = doc(db, 'wordleScorecards', courseName);
      const snap = await getDoc(ref);
      if (!snap.exists()) {
        await setDoc(ref, { course: courseName, players: buildDefaultPlayers(), updatedAt: serverTimestamp() });
      }
    }

    async function attachListenerForCourse(courseName) {
      if (unsubscribe) { unsubscribe(); unsubscribe = null; }
      if (!db) return; // offline or config missing

      await ensureDocExists(courseName);
      const ref = doc(db, 'wordleScorecards', courseName);

      unsubscribe = onSnapshot(ref, snap => {
        if (!snap.exists()) return;
        const serverData = snap.data();
        const localData = readTableData();

        if (!sameData(
          { course: localData.course, players: localData.players },
          { course: serverData.course, players: serverData.players }
        )) {
          applyingRemote = true;
          currentPar = courses[courseName];
          updateParRow(currentPar);
          renderFromData(serverData);
          applyingRemote = false;
        }
      });
    }

    async function loadScorecard(courseName) {
      currentPar = courses[courseName];
      updateParRow(currentPar);

      // Render something immediately so the table never looks empty
      renderFromData({ players: buildDefaultPlayers() });

      // Then attach realtime sync
      await attachListenerForCourse(courseName);
    }

    // ---------- Boot ----------
    const last = localStorage.getItem('lastCourse');
    courseSelect.value = last && courses[last] ? last : Object.keys(courses)[0];
    loadScorecard(courseSelect.value);

    updateMiniBoard();

    courseSelect.addEventListener('change', e => {
      localStorage.setItem('lastCourse', e.target.value);
      loadScorecard(e.target.value);
    });

// ---------- Clear Scores Button ----------
document.getElementById('clearBtn').addEventListener('click', async () => {
  if (!confirm("Clear all player scores for this course?")) return;

  const playersCleared = Array.from(tbody.querySelectorAll('tr')).map((row, i) => {
    const name = row.querySelector('input[type="text"]')?.value || `Player ${i+1}`;
    return { name, scores: [] };
  });

  // Update the table immediately
  renderFromData({ players: playersCleared });
  updateParRow(currentPar);

  updateMiniBoard();

  // Push to Firestore
  try {
    const ref = doc(db, 'wordleScorecards', courseSelect.value);
    await setDoc(ref, {
      course: courseSelect.value,
      players: playersCleared,
      updatedAt: serverTimestamp()
    }, { merge: true });
    console.log("Scores cleared");
  } catch (err) {
    console.error("Clear scores failed:", err);
    alert("Clear failed. Check console.");
  }
});
    
  </script>

<script>
(function () {
  const box = document.getElementById('wordBox');
  if (!box) return;

  const words = [
    { word: "Paronomasia",   def: "A fancy word for a pun or wordplay." },
    { word: "Birdie",        def: "Golf: one under par. Also, a small bird." },
    { word: "Lexicon",       def: "The vocabulary of a person, language, or field." },
    { word: "Bogey",         def: "Golf: one over par. Slang: an adversary." },
    { word: "Sesquipedalian",def: "Given to using long words." },
    { word: "Ace",           def: "Golf: hole-in-one. Also: someone excellent at something." }
  ];

  // deterministic 'word of the day' so all players see the same one
  const seed = new Date().toDateString();
  let hash = 0; for (let i = 0; i < seed.length; i++) hash = (hash*31 + seed.charCodeAt(i)) >>> 0;
  const pick = words[hash % words.length];

  box.innerHTML = `
    <h4>Word of the Day</h4>
    <span class="w">${pick.word}</span>
    <span class="d"> — ${pick.def}</span>
  `;
})();
</script>
  
</body>
</html>
