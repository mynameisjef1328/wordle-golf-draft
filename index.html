<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Wordle Golf Scorecard</title>

  <style>
    /* =========================
       Design tokens / palette
       ========================= */
    :root{
      --bg: #f7f7f8;
      --text: #111;
      --muted: #6b7280;
      --border: #d8d8dc;
      --card: #ffffff;

      --accent: #0B6623;   /* ‚ÄúMasters‚Äù green */
      --accent-800:#084d1a;

      --good: #c9f7cf;
      --bad:  #ffd3d3;
      --even: #ffffff;

      --radius: 10px;
      --shadow: 0 6px 18px rgba(0,0,0,.08);
      --shadow-soft: 0 2px 10px rgba(0,0,0,.06);
      --gap: 12px;
    }

    /* =========================
       Base layout & typography
       ========================= */
    html,body{height:100%}
    body{
      margin: 24px;
      background: var(--bg);
      color: var(--text);
      font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
    }

    h2{
      margin: 0 0 12px;
      font-size: clamp(22px, 2.6vw, 36px);
      letter-spacing: .2px;
    }

    /* Toolbar (uses your existing elements/IDs) */
    .toolbar{
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin: 10px 0 12px;
    }

    select, button{
      height: 36px;
      border-radius: 8px;
      border: 1px solid var(--border);
      padding: 0 12px;
      background: var(--card);
      color: var(--text);
      box-shadow: var(--shadow-soft);
    }
    button{
      cursor: pointer;
      background: #fff;
      transition: transform .04s ease, box-shadow .2s ease, background .2s ease;
    }
    button:hover{ box-shadow: var(--shadow); }
    button:active{ transform: translateY(1px); }

    /* =========================
       Scorecard table
       ========================= */
    table{ border-collapse: separate; border-spacing: 0; width: 100%; overflow: hidden; border-radius: var(--radius); background: var(--card); box-shadow: var(--shadow); }
    th, td{
      border: 1px solid var(--border);
      padding: 10px 8px;
      text-align: center;
      font-variant-numeric: tabular-nums;
    }
    thead th{
      background: #8b8f95;
      color: #fff;
      text-transform: none;
      font-weight: 700;
      position: sticky;
      top: 0;
      z-index: 3;
    }
    /* sticky first column */
    th:first-child, td:first-child{
      position: sticky;
      left: 0;
      background: #f0f1f3;
      z-index: 2;
      background-clip: padding-box;
      box-shadow: 2px 0 0 rgba(0,0,0,.06);
    }
    /* subtle zebra for readability */
    tbody tr:nth-child(even) td{ background: #fcfcfd; }

    /* Inputs */
    input[type="number"], input[type="text"]{
      width: 64px;           /* a touch wider */
      height: 34px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #fff;
      text-align: center;
      outline: none;
      transition: border-color .15s ease, box-shadow .15s ease, background .15s ease;
    }
    input[type="text"]{ width: 120px; text-align: left; padding: 0 10px; }
    input:focus{
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(11,102,35,.15);
      background: #fff;
    }

    /* Par coloring (keep your class names) */
    td.under-par{ background: var(--good) !important; }
    td.over-par { background: var(--bad) !important; }
    td.even-par { background: var(--even) !important; }

    /* Player label row at top of body (kept from your JS) */
    .player-label td{
      font-weight: 700;
      background: #f0f1f3 !important;
      text-align: left;
    }

    /* =========================
       Reusable "card" style
       ========================= */
    .card{
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      color: var(--text);
    }
    .card h4{ margin: 0 0 6px; font-weight: 800; font-size: 14px; letter-spacing:.2px; }

    /* =========================
       Floating HUD blocks
       ========================= */
    #miniBoard{
      position: fixed;
      bottom: max(12px, env(safe-area-inset-bottom));
      left: max(12px, env(safe-area-inset-left));
      min-width: 190px;
      max-width: 260px;
      padding: 10px 12px;
      z-index: 4;
    }
    #miniBoard .row{ display:flex; justify-content: space-between; gap: 8px; padding: 2px 0; }
    #miniBoard .name{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    #miniBoard .score{ font-variant-numeric: tabular-nums; }

    /* Word of the Day (green card) */
    #wordBox{
      position: fixed;
      bottom: max(12px, env(safe-area-inset-bottom));
      left: calc(max(12px, env(safe-area-inset-left)) + 200px); /* clears miniBoard */
      max-width: min(720px, 60vw);
      padding: 14px 18px;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      z-index: 4;

      background: var(--accent);
      border: 1px solid var(--accent-800);
      color: #fff;
      font-size: clamp(18px, 1.8vw, 22px);
      font-weight: 800;
      line-height: 1.55;
    }
    #wordBox h4{ margin: 0 0 8px; font-size: 16px; font-weight: 900; opacity:.95; }
    #wordBox .d{ font-weight: 700; opacity: .95; }

    /* Rules (right edge) */
    #rulesBox{
      position: fixed;
      right: max(12px, env(safe-area-inset-right));
      bottom: max(12px, env(safe-area-inset-bottom));
      width: min(320px, 28vw);
      max-height: 220px;
      overflow: auto;
      padding: 12px 16px;
      z-index: 4;
    }
    #rulesBox h4{ margin: 0 0 6px; font-size: 15px; font-weight: 900; }
    #rulesBox ul{ margin: 6px 0 0; padding-left: 20px; }
    #rulesBox li{ margin: 4px 0; color: #1f2937; }

    /* Make miniBoard/word/rules share the card look */
    #miniBoard, #rulesBox{ composes: card; } /* (for editors that support it) */
    /* Fallback for plain CSS: duplicate core properties */
    #miniBoard, #rulesBox{
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      color: var(--text);
    }

    /* =========================
       Responsive tweaks
       ========================= */
    @media (max-width: 1200px){
      #wordBox{ max-width: 56vw; }
      #rulesBox{ width: min(300px, 32vw); }
    }
    @media (max-width: 900px){
      /* stack the HUD pieces neatly */
      #miniBoard{ left: max(8px, env(safe-area-inset-left)); bottom: max(8px, env(safe-area-inset-bottom)); }
      #wordBox{
        left: 50%;
        transform: translateX(-50%);
        width: calc(100% - 24px);
        max-width: 720px;
      }
      #rulesBox{
        right: max(8px, env(safe-area-inset-right));
        width: calc(100% - 24px);
        max-width: 520px;
        bottom: calc(max(8px, env(safe-area-inset-bottom)) + 92px); /* lift above word box */
      }
    }
  </style>
</head>
<body>
  <h2>Wordle Golf Scorecard</h2>

  <div class="toolbar">
    <label for="courseSelect">Choose a course:</label>
    <select id="courseSelect"></select>
    <button id="clearBtn">Clear Scores</button>
    <button id="clearNamesBtn" type="button">Clear Names</button>
  </div>

  <table id="scorecard">
    <thead>
      <tr>
        <th></th>
        <th colspan="18">Hole</th>
        <th>Total</th>
        <th>+/-</th>
      </tr>
      <tr>
        <th></th>
        <script>
          for (let i = 1; i <= 18; i++) document.write(`<th>${i}</th>`);
        </script>
        <th>Par</th>
        <th></th>
      </tr>
      <tr id="parRow"><th>Par</th></tr>
    </thead>
    <tbody></tbody>
  </table>

  <!-- Floating HUD -->
  <div id="miniBoard" class="card" aria-live="polite"></div>
  <div id="wordBox" aria-live="polite"></div>
  <div id="rulesBox" class="card" aria-live="polite">
    <h4>üèåÔ∏è Wordle Golf Rules</h4>
    <ul>
      <li>Each hole = one Wordle puzzle (one per day).</li>
      <li>Your score = number of guesses used to solve the Wordle.</li>
      <li>Solve it in <strong>3 tries</strong> ‚Üí you score <strong>3</strong> (like 3 strokes).</li>
      <li>If you <strong>don‚Äôt solve in 6 tries</strong> or <strong>forget to play</strong>, your score = <strong>7</strong>.</li>
      <li>Lowest total score wins, just like golf.</li>
      <li>Track progress hole by hole, and compare live scores with friends!</li>
    </ul>
  </div>

  <!-- ===== Your existing JS (unchanged functionality) ===== -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
    import { getFirestore, doc, getDoc, setDoc, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyC9-Z6E59grKoq_pD8acGTre2Jx-1NQ_Qc",
      authDomain: "wordle-golf-6c636.firebaseapp.com",
      projectId: "wordle-golf-6c636",
      storageBucket: "wordle-golf-6c636.appspot.com",
      messagingSenderId: "672104265687",
      appId: "1:672104265687:web:2c16b0539fcd52ca4d7d92"
    };

    let app, db;
    (async () => {
      try {
        app = initializeApp(firebaseConfig);
        db  = getFirestore(app);
        await setDoc(doc(db, "diagnostics", "ping"), { ok: true, ts: Date.now() }, { merge: true });
      } catch (e) { console.error("Firebase init/ping error:", e); }
    })();

    async function testWriteCourse(course = "Bully Pulpit") {
      try {
        await setDoc(doc(db, "wordleScorecards", course), {
          course,
          players: [
            { name: "Tester 1", scores: ["3","4","","","","","","","","","","","","","","","",""] },
            { name: "Tester 2", scores: [] },
            { name: "Player 3", scores: [] },
            { name: "Player 4", scores: [] }
          ],
          updatedAt: serverTimestamp()
        }, { merge: true });
      } catch (e) { console.error("testWriteCourse error:", e); }
    }
    testWriteCourse();

    // ---------- Data ----------
    const courses = {
      'Sweetwater Creek': [4,4,3,4,5,4,4,3,5,4,3,4,5,4,4,3,4,5],
      'St. Andrews':  [4,5,4,3,4,4,5,3,4,4,3,5,4,4,3,4,5,4],
      'Augusta':      [5,4,3,4,5,3,4,4,4,3,5,4,4,3,4,5,4,3],
      'Bully Pulpit':  [4,3,5,4,4,3,4,5,4,4,3,4,4,5,3,4,5,4],
      'Torrey Pines': [4,4,5,3,4,5,4,3,4,4,4,5,3,4,4,5,3,4],
      'TPC Sawgrass': [4,4,3,5,4,3,4,5,4,3,4,5,4,4,3,5,4,3],
      'Bethpage Black': [4,5,3,4,4,5,4,4,3,4,5,3,4,4,5,3,4,4],
      'Whistling Straits': [4,3,5,4,4,5,3,4,4,5,4,3,4,4,5,4,3,4],
      'Pebble Beach': [4,4,5,3,4,3,4,5,4,4,4,5,3,4,4,5,3,4],
      'Congrssional': [3,4,5,4,3,5,4,4,4,5,4,3,4,5,4,4,3,4]
    };

    const parRow = document.getElementById('parRow');
    const courseSelect = document.getElementById('courseSelect');
    const tbody = document.querySelector('#scorecard tbody');

    Object.keys(courses).forEach(course => {
      const option = document.createElement('option');
      option.value = course;
      option.textContent = course;
      courseSelect.appendChild(option);
    });

    let currentPar = [];
    let unsubscribe = null;
    let applyingRemote = false;

    function updateParRow(parValues) {
      parRow.innerHTML = '';
      parRow.innerHTML += '<th></th>';
      parValues.forEach(par => {
        const th = document.createElement('th');
        th.textContent = par;
        parRow.appendChild(th);
      });
      const parTotal = parValues.reduce((sum, p) => sum + p, 0);
      parRow.innerHTML += `<th>${parTotal}</th>`;
      parRow.innerHTML += '<th></th>';
    }

    function buildPlayerRow(name = '', rowIndex = 0, savedScores = []) {
      const row = document.createElement('tr');

      const nameCell = document.createElement('td');
      const nameInput = document.createElement('input');
      nameInput.type = 'text';
      nameInput.value = name;
      nameInput.addEventListener('input', () => saveScoresToFirestore());
      nameCell.appendChild(nameInput);
      row.appendChild(nameCell);

      for (let i = 0; i < 18; i++) {
        const cell = document.createElement('td');
        const input = document.createElement('input');
        input.type = 'number';
        input.min = 1;
        input.value = savedScores[i] || '';
        input.addEventListener('input', () => {
          calculate(row);
          saveScoresToFirestore();
        });
        cell.appendChild(input);
        row.appendChild(cell);
      }

      const totalCell = document.createElement('td');
      totalCell.className = 'total';
      totalCell.textContent = '0';
      row.appendChild(totalCell);

      const diffCell = document.createElement('td');
      diffCell.className = 'diff';
      diffCell.textContent = '0';
      row.appendChild(diffCell);

      setTimeout(() => calculate(row), 0);
      return row;
    }

    function calculate(row) {
      const inputs = row.querySelectorAll('input[type="number"]');
      let total = 0;
      let parTotal = 0;

      inputs.forEach((input, index) => {
        const val = parseInt(input.value);
        const par = currentPar[index];
        const cell = input.parentElement;
        cell.className = '';
        if (!isNaN(val)) {
          total += val;
          parTotal += par;
          if (val < par) cell.className = 'under-par';
          else if (val > par) cell.className = 'over-par';
          else cell.className = 'even-par';
        }
      });

      row.querySelector('.total').textContent = total || '0';
      const diff = total - parTotal;
      row.querySelector('.diff').textContent = total
        ? (diff > 0 ? `+${diff}` : `${diff}`)
        : '0';

      updateMiniBoard();
    }

    function updateMiniBoard() {
      const box = document.getElementById('miniBoard');
      if (!box) return;

      const rows = Array.from(tbody.querySelectorAll('tr'));
      const items = rows
        .map(r => {
          const name = r.querySelector('input[type="text"]')?.value?.trim() || '';
          const total = parseInt(r.querySelector('.total')?.textContent || '0', 10) || 0;
          const diffTxt = (r.querySelector('.diff')?.textContent || '0').toString();
          return { name, total, diffTxt };
        })
        .filter(p => p.name);

      if (!items.length) {
        box.innerHTML = `<h4>Live Scores</h4>
          <div class="row"><span class="name">Enter scores to begin</span></div>`;
        return;
      }

      items.sort((a, b) => (a.total || 9999) - (b.total || 9999));

      box.innerHTML =
        `<h4>Live Scores</h4>` +
        items
          .map(
            p => `<div class="row">
                    <span class="name">${p.name}</span>
                    <span class="score">${p.total} (${p.diffTxt})</span>
                  </div>`
          )
          .join('');
    }

    const buildDefaultPlayers = () =>
      Array.from({ length: 4 }, (_, i) => ({ name: `Player ${i + 1}`, scores: [] }));

    function readTableData() {
      const data = { course: courseSelect.value, players: [] };
      tbody.querySelectorAll('tr').forEach(row => {
        const name = row.querySelector('input[type="text"]')?.value || '';
        const scores = Array.from(row.querySelectorAll('input[type="number"]')).map(i => i.value);
        data.players.push({ name, scores });
      });
      return data;
    }

    async function saveScoresToFirestore() {
      if (applyingRemote || !db) return;
      const data = readTableData();
      const ref = doc(db, 'wordleScorecards', data.course);
      await setDoc(ref, { course: data.course, players: data.players, updatedAt: serverTimestamp() }, { merge: true });
    }

    function sameData(a, b) {
      try { return JSON.stringify(a) === JSON.stringify(b); } catch { return false; }
    }

    function renderFromData(docData) {
      tbody.innerHTML = '';

      const labelRow = document.createElement('tr');
      labelRow.classList.add('player-label');
      const labelCell = document.createElement('td');
      labelCell.textContent = 'Player';
      labelRow.appendChild(labelCell);
      for (let i = 0; i < 20; i++) { labelRow.appendChild(document.createElement('td')); }
      tbody.appendChild(labelRow);

      const players = docData?.players?.length ? docData.players : buildDefaultPlayers();
      players.forEach((p, i) => tbody.appendChild(buildPlayerRow(p.name, i, p.scores || [])));

      updateMiniBoard();
    }

    async function ensureDocExists(courseName) {
      if (!db) return;
      const ref = doc(db, 'wordleScorecards', courseName);
      const snap = await getDoc(ref);
      if (!snap.exists()) {
        await setDoc(ref, { course: courseName, players: buildDefaultPlayers(), updatedAt: serverTimestamp() });
      }
    }

    async function attachListenerForCourse(courseName) {
      if (unsubscribe) { unsubscribe(); unsubscribe = null; }
      if (!db) return;

      await ensureDocExists(courseName);
      const ref = doc(db, 'wordleScorecards', courseName);

      unsubscribe = onSnapshot(ref, snap => {
        if (!snap.exists()) return;
        const serverData = snap.data();
        const localData = readTableData();

        if (!sameData(
          { course: localData.course, players: localData.players },
          { course: serverData.course, players: serverData.players }
        )) {
          applyingRemote = true;
          currentPar = courses[courseName];
          updateParRow(currentPar);
          renderFromData(serverData);
          applyingRemote = false;
        }
      });
    }

    async function loadScorecard(courseName) {
      currentPar = courses[courseName];
      updateParRow(currentPar);
      renderFromData({ players: buildDefaultPlayers() });
      await attachListenerForCourse(courseName);
    }

    const last = localStorage.getItem('lastCourse');
    courseSelect.value = last && courses[last] ? last : Object.keys(courses)[0];
    loadScorecard(courseSelect.value);
    updateMiniBoard();

    courseSelect.addEventListener('change', e => {
      localStorage.setItem('lastCourse', e.target.value);
      loadScorecard(e.target.value);
    });

    document.getElementById('clearBtn').addEventListener('click', async () => {
      if (!confirm("Clear all player scores for this course?")) return;

      const playersCleared = Array.from(tbody.querySelectorAll('tr')).map((row, i) => {
        const name = row.querySelector('input[type="text"]')?.value || `Player ${i+1}`;
        return { name, scores: [] };
      });

      renderFromData({ players: playersCleared });
      updateParRow(currentPar);
      updateMiniBoard();

      try {
        const ref = doc(db, 'wordleScorecards', courseSelect.value);
        await setDoc(ref, { course: courseSelect.value, players: playersCleared, updatedAt: serverTimestamp() }, { merge: true });
      } catch (err) {
        console.error("Clear scores failed:", err);
        alert("Clear failed. Check console.");
      }
    });
  </script>

  <!-- Word of the Day (deterministic pick) -->
  <script>
    (function () {
      const box = document.getElementById('wordBox');
      if (!box) return;

      const words = [
        { word: "Aphelion", def: "The point in the orbit of a planet where it is farthest from the sun." },
        { word: "Bruxism", def: "The involuntary grinding of teeth, especially while sleeping." },
        { word: "Cacophony", def: "A harsh, discordant mixture of sounds." },
        { word: "Defenestration", def: "The act of throwing someone or something out of a window." },
        { word: "Ephemeral", def: "Lasting for a very short time." },
        { word: "Fugacious", def: "Tending to disappear; fleeting." },
        { word: "Grawlix", def: "A string of typographical symbols used to represent profanity." },
        { word: "Halcyon", def: "Denoting a period of time in the past that was idyllically happy and peaceful." },
        { word: "Ichthyology", def: "The branch of zoology that deals with fish." },
        { word: "Jentacular", def: "Pertaining to breakfast." },
        { word: "Kerfuffle", def: "A commotion or fuss." },
        { word: "Limerence", def: "The state of being infatuated or obsessed with another person." },
        { word: "Mumpsimus", def: "A stubborn person who insists on making an error in spite of being shown it's wrong." },
        { word: "Noisome", def: "Having an extremely offensive smell." },
        { word: "Ostentatious", def: "Characterized by vulgar or pretentious display." },
        { word: "Peregrinate", def: "To travel or wander around from place to place." },
        { word: "Quixotic", def: "Exceedingly idealistic; unrealistic and impractical." },
        { word: "Recumbent", def: "Lying down." },
        { word: "Susurrus", def: "Whispering, murmuring, or rustling." },
        { word: "Tmesis", def: "Inserting a word into another word, like 'abso-bloody-lutely'." },
        { word: "Ululate", def: "To howl or wail as an expression of strong emotion." },
        { word: "Vicissitude", def: "A change of circumstances or fortune, typically unwelcome." },
        { word: "Weltschmerz", def: "A feeling of melancholy and world-weariness." },
        { word: "Xanthic", def: "Relating to a yellow color." },
        { word: "Ylem", def: "In Big Bang theory, the primordial matter forming elements." },
        { word: "Zugzwang", def: "In chess, any move worsens your position." },
        { word: "Agog", def: "Very eager or curious to see something." },
        { word: "Borborygmus", def: "Rumbling noise from gas moving in the intestines." },
        { word: "Catachresis", def: "Incorrect use of a word or phrase." },
        { word: "Dysania", def: "Finding it hard to get out of bed in the morning." },
        { word: "Eucatastrophe", def: "A sudden favorable resolution of events in a story." },
        { word: "Floccinaucinihilipilification", def: "Estimating something as worthless." },
        { word: "Gobbledygook", def: "Language that‚Äôs meaningless or hard to understand; jargon." },
        { word: "Hiraeth", def: "Homesickness for a home you can‚Äôt return to or never had." },
        { word: "Insouciant", def: "Showing a casual lack of concern; indifferent." },
        { word: "Jargogle", def: "To confuse or jumble." },
        { word: "Kakistocracy", def: "Government by the worst or least qualified." },
        { word: "Lethologica", def: "The inability to recall the right word." },
        { word: "Montivagant", def: "Wandering over hills and mountains." },
        { word: "Nudiustertian", def: "Relating to the day before yesterday." },
        { word: "Opsimath", def: "A person who begins to study late in life." },
        { word: "Psithurism", def: "The sound of wind through trees." },
        { word: "Quomodocunquize", def: "To make money by any means possible." },
        { word: "Raconteur", def: "A skilled, amusing storyteller." },
        { word: "Scripturient", def: "Having a strong urge to write." },
        { word: "Tittynope", def: "A small quantity left over." },
        { word: "Uhtceare", def: "Lying awake before dawn and worrying." },
        { word: "Vorfreude", def: "Joyful anticipation of future pleasures." },
        { word: "Wamble", def: "Stomach rumbling or uneasiness." },
        { word: "Xenization", def: "Traveling as a stranger." }
      ];

      const seed = new Date().toDateString();
      let hash = 0; for (let i = 0; i < seed.length; i++) hash = (hash*31 + seed.charCodeAt(i)) >>> 0;
      const pick = words[hash % words.length];

      box.innerHTML = `
        <h4>Word of the Day</h4>
        <span class="w">${pick.word}</span>
        <span class="d"> ‚Äî ${pick.def}</span>
      `;
    })();
  </script>
</body>
</html>
